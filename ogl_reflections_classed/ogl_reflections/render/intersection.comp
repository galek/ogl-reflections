#version 450 core
#extension GL_NV_gpu_shader5 : enable

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

struct Thash {
	uint triangle;
	uint previous;
};

struct Voxel {
	uint last;
    uint count;
    uint coordX;
	uint coordY;
	uint coordZ;
    //f16vec4 color;
    //f16vec4 normal;
};

layout(std430, binding=0) buffer s_voxels {Voxel voxels[];};
layout(std430, binding=1) buffer s_voxels_sub {uint voxels_subgrid[];};
layout(std430, binding=2) buffer s_thashes {Thash thashes[];};
layout(std430, binding=3) buffer s_vbo {float verts[];};
layout(std430, binding=4) buffer s_ebo {uint indics[];};
layout(std430, binding=5) buffer s_norm {float norms[];};
layout(std430, binding=6) buffer s_tex {float texcs[];};
layout(std430, binding=7) buffer s_mat {int mats[];};

/* ============ RAYS ============= */

struct Ray {
    uint previous;
    uint hit;
    uint shadow;
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
    vec4 params0;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 params;
};

struct Texel {
    uint last;
    uint count;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};
layout(std430, binding=10) buffer s_texels {Texel texelInfo[];};
layout (binding=0) uniform atomic_uint rcounter;
layout (binding=1) uniform atomic_uint hcounter;

uint createRay(in Ray original){
    uint hidx = atomicCounterIncrement(hcounter);
    uint ridx = atomicCounterIncrement(rcounter);
    Ray ray = original;
    ray.hit = hidx;
    Hit hit;
    hit.dist = 10000.0f;
    hit.triangle = LONGEST;
    hit.materialID = LONGEST;
    hits[hidx] = hit;
    rays[ridx] = ray;
    return ridx;
}

uint createRay(){
    Ray newRay;
    return createRay(newRay);
}

void storeTexel(in uint texel, in uint rayIndex){
    rays[rayIndex].previous = atomicExchange(texelInfo[texel].last, rayIndex);
    atomicAdd(texelInfo[texel].count, 1);
}

void storeRay(in uint rayIndex, in Ray ray){
    rays[rayIndex].direct = ray.direct;
    rays[rayIndex].origin = ray.origin;
    rays[rayIndex].actived = ray.actived;
    rays[rayIndex].color = ray.color;
    rays[rayIndex].final = ray.final;
    rays[rayIndex].params = ray.params;
    rays[rayIndex].params0 = ray.params0;
}

void storeHit(in Ray ray, in Hit hit){
    hits[ray.hit].dist = hit.dist;
    hits[ray.hit].triangle = hit.triangle;
    hits[ray.hit].normal = hit.normal;
    hits[ray.hit].texcoord = hit.texcoord;
    hits[ray.hit].tangent = hit.tangent;
    hits[ray.hit].materialID = hit.materialID;
    hits[ray.hit].params = hit.params;
}

Ray fetchFirstRay(in uint texel){
    return rays[texelInfo[texel].last];
}

Ray fetchNextRay(in Ray ray){
    return rays[ray.previous];
}

/* ============ END =========== */


uniform vec2 sceneRes;
uniform uint maxDepth;
uniform vec3 offset;
uniform vec3 scale;


float lengthFast(in vec3 v){
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

vec3 normalizeFast(in vec3 v){
    return v / lengthFast(v);
}

uint cnv_subgrid(uint sub, uvec3 idu){
    return sub * 8 + (idu.x + idu.y * 2 + idu.z * 4);
}

uint searchVoxelIndex(uvec3 idx, uint maxDepth){
    uint currentDepth = maxDepth-1;
    uvec3 id = uvec3(0);
    bool fail = false;
    uint sub = 0;
    Voxel hash = voxels[sub];
    uvec3 idu = uvec3(0);
    uint grid = 0;

    int strt = int(currentDepth);
    for(int i=strt;i>=0;i--){
        if(!fail){
            id = uvec3(idx / uint(pow(2, i)));
            idu = id % uvec3(2);
            if(i == strt){
                grid = 0;
                sub = 0;
            } else {
                grid = cnv_subgrid(sub, idu);
                sub = voxels_subgrid[grid];
            }
            if(sub == LONGEST) {
                fail = true;
            } else {
                hash = voxels[sub];
            }
        } else {
            break;
        }
    }

    if(!fail){
        return sub;
    }
    return LONGEST;
}

uint searchVoxelIndex(uvec3 idx){
    return searchVoxelIndex(idx, maxDepth);
}

Voxel loadVoxel(in uvec3 coord, in uint depth){
    if(coord.x != LONGEST){
        uint idx = searchVoxelIndex(coord, depth+1);
        return voxels[idx];
    } else {
        Voxel voxel;
        voxel.last = LONGEST;
        voxel.count = 0;
        return voxel;
    }
}

Voxel loadVoxel(in uvec3 coord){
    return loadVoxel(coord, maxDepth-1);
}

vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
   vec3 tMin = (cubeMin - origin) / ray;
   vec3 tMax = (cubeMax - origin) / ray;
   vec3 t1 = min(tMin, tMax);
   vec3 t2 = max(tMin, tMax);
   float tNear = max(max(t1.x, t1.y), t1.z);
   float tFar = min(min(t2.x, t2.y), t2.z);
   if( tNear <= tFar ){
       return vec2(tNear, tFar);
   } else {
       return vec2(INFINITY, INFINITY);
   }
}

float intersect(in vec3 orig, in vec3 dir, in vec3 vertices[3], inout vec2 UV){
    vec3 u, v, n; // triangle vectors
    vec3 w0, w;  // ray vectors
    float r, a, b; // params to calc ray-plane intersect

    // get triangle edge vectors and plane normal
    u = vertices[1] - vertices[0];
    v = vertices[2] - vertices[0];
    n = cross(u, v);

    w0 = orig - vertices[0];
    a = -dot(n, w0);
    b = dot(n, dir);
    if (abs(b) < 1e-5)
    {
        // ray is parallel to triangle plane, and thus can never intersect.
        return INFINITY;
    }

    // get intersect point of ray with triangle plane
    r = a / b;
    if (r < 0.0)
        return INFINITY; // ray goes away from triangle.

    vec3 I = orig + r * dir;
    float uu, uv, vv, wu, wv, D;
    uu = dot(u, u);
    uv = dot(u, v);
    vv = dot(v, v);
    w = I - vertices[0];
    wu = dot(w, u);
    wv = dot(w, v);
    D = uv * uv - uu * vv;

    // get and test parametric coords
    float s, t;
    s = (uv * wv - vv * wu) / D;
    if (s < 0.0 || s > 1.0)
        return INFINITY;
    t = (uv * wu - uu * wv) / D;
    if (t < 0.0 || (s + t) > 1.0)
        return INFINITY;

    UV = vec2(s, t);
    return (r > 1e-5) ? r : INFINITY;
}

struct TResult {
    float dist;
    uint triangle;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    int materialID;
};

TResult test_intersection(in vec3 orig, in vec3 dir, in Voxel vox){
    Thash hash = thashes[vox.last];
    bool needsSkip = false;

    const uint globalTCount = 3000;
    const uint triangleCount = globalTCount;

    float d = INFINITY;
    int materialID = -1;
    uint lastT = LONGEST;
    vec3 normal;
    vec2 texcoord;
    vec3 tangent;
    for(uint i=0;i<=min(vox.count, triangleCount);i++){
        if(!needsSkip){
            uint tri = hash.triangle;

            vec3 triverts[3];
            uint ji[3];
            for(uint x=0;x<3;x++){
                uint j = indics[tri * 3 + x]; ji[x] = j;
                triverts[x] = vec3(verts[j * 3 + 0], verts[j * 3 + 1], verts[j * 3 + 2]);
            }

            vec2 uv;
            float _d = intersect(orig, dir, triverts, uv);
            if(_d >= 0.0f && _d < d) {
                d = _d;
                lastT = tri;

                vec3 trinorms[3];
                vec2 texcoords[3];
                for(uint x=0;x<3;x++){
                    uint j = ji[x];
                    trinorms[x] = vec3(norms[j * 3 + 0], norms[j * 3 + 1], norms[j * 3 + 2]);
                    texcoords[x] = vec2(texcs[j * 2 + 0], texcs[j * 2 + 1]);
                }

                normal = cross(triverts[2] - triverts[0], triverts[1] - triverts[0]);
                normal = normalizeFast(trinorms[1]) * uv.x;
                normal += normalizeFast(trinorms[2]) * uv.y;
                normal += normalizeFast(trinorms[0]) * (1.0f - uv.x - uv.y);
                normal = normalizeFast(normal);

                texcoord = texcoords[1] * uv.x;
                texcoord += texcoords[2] * uv.y;
                texcoord += texcoords[0] * (1.0f - uv.x - uv.y);
                texcoord.y = 1.0f - texcoord.y;
                //texcoord = vec2(0.0);

                vec3 deltaPos;
                if(abs(dot(triverts[0] - triverts[1], vec3(1.0f))) < 0.001f) {
                    deltaPos = triverts[2] - triverts[0];
                } else {
                    deltaPos = triverts[1] - triverts[0];
                }
                vec2 deltaUV1 = texcoords[1] - texcoords[0];
                vec2 deltaUV2 = texcoords[2] - texcoords[0];
                vec3 tan;
                if(deltaUV1.s != 0.0f) {
                    tan = deltaPos / deltaUV1.s;
                } else {
                    tan = deltaPos / 1.0f;
                }
                tan = normalizeFast(tan - dot(normal,tan)*normal);

                tangent = tan;
                materialID = mats[tri];
            }

            uint previous = hash.previous;
            if(previous != LONGEST){
                hash = thashes[previous];
            } else {
                needsSkip = true;
            }
        }
    }

    TResult res;
    res.dist = d;
    res.triangle = lastT;
    res.normal = normal;
    res.texcoord = texcoord;
    res.materialID = materialID;
    res.tangent = tangent;
    return res;
}

vec3 projectVoxels(in vec3 orig, in uint maxDepth){
    vec3 torig = orig;
    uint resX = uint(pow(2, maxDepth-1));
    torig -= offset;
    torig /= scale;
    torig *= resX;
    return torig;
}

TResult traverse(vec3 orig, vec3 dir){
    uint currentDepth = maxDepth-1;
    uint resX = uint(pow(2, currentDepth));
    vec3 torig = projectVoxels(orig, currentDepth+1);
    vec2 d = intersectCube(torig, dir, vec3(0.0f), vec3(resX));

    TResult lastRes;
    lastRes.triangle = 0xFFFFFFFF;
    lastRes.dist = INFINITY;

    if(d.y >= 0.0f && d.x < INFINITY && d.y < INFINITY){
        vec3 ray_start = torig + dir * 0.001f;
        if(d.x >= 0.0f) {
            ray_start = (torig + dir * (d.x + 0.001f));
        }
        vec3 ray_end = (torig + dir * (d.y + 0.001f));

        float _bin_size = 1.0f;
        vec3 p0 = ray_start / _bin_size;
        vec3 p1 = ray_end / _bin_size;

        vec3 step = sign(p1 - p0);
        if(abs(step.x) < 0.001f) step.x = 1.0f;
        if(abs(step.y) < 0.001f) step.y = 1.0f;
        if(abs(step.z) < 0.001f) step.z = 1.0f;
        vec3 delta = _bin_size / abs(p1 - p0);
        vec3 test = floor(p0);
        vec3 mx = delta * mix(fract(p0), 1.0 - fract(p0), step * 0.5 + 0.5);

        const uint iterationCount = uint(ceil(float(resX) * sqrt(3.0f))) * 2;
        uint iteration = 0;

        do {
            iteration++;

            bool overlap = false;
            bool found = false;
            uvec3 coord = uvec3(test);
            Voxel vox = loadVoxel(coord, currentDepth);
            if(vox.count > 0 && vox.last != LONGEST) {
                vec3 mnc = test - 0.001f;
                vec3 mxc = mnc + 1.0f + 0.001f;
                vec2 d = intersectCube(ray_start, dir, mnc, mxc);
                if(d.y >= 0.0f && d.x < INFINITY && d.y < INFINITY){
                    overlap = true;
                    TResult lres = test_intersection(orig, dir, vox);
                    if(lres.dist < lastRes.dist){
                        lastRes = lres;
                    } else

                    if(
                        lastRes.triangle != LONGEST &&
                        lastRes.dist >= 0.0f &&
                        lastRes.dist < INFINITY
                    ) {
                        return lastRes;
                        break;
                    }
                }
            }

            if(!overlap){
                if(
                    lastRes.triangle != LONGEST &&
                    lastRes.dist >= 0.0f &&
                    lastRes.dist < INFINITY
                ) {
                    return lastRes;
                    break;
                }

                float coef = 1.0f;
                vec3 tst = test;
                vec3 coordf = tst;
                for(int i=int(currentDepth)-1;i>=0;i--){
                    float dX = pow(2, currentDepth - i);
                    coordf = floor(tst / dX);

                    vec3 mnc = coordf * dX - 0.001f;
                    vec3 mxc = (coordf + 1.0f) * dX + 0.001f;
                    Voxel vox = loadVoxel(uvec3(coordf), i);
                    if(vox.count > 0 && vox.last != LONGEST){
                        break;
                    } else {
                        vec2 d = intersectCube(ray_start, dir, mnc, mxc);
                        if(d.y >= 0.0f && d.x < INFINITY && d.y < INFINITY){
                            found = true;
                            vec3 p0 = (ray_start + dir * (d.y + 0.001f)) / _bin_size;
                            test = floor(p0);
                            mx = delta * mix(fract(p0), 1.0 - fract(p0), step * 0.5 + 0.5);
                        }
                    }
                }
            }

            if(!found){
                if (mx.x < mx.y) {
                    if (mx.x < mx.z) {
                        test.x += step.x;
                        mx.x += delta.x;
                    } else {
                        test.z += step.z;
                        mx.z += delta.z;
                    }
                } else {
                    if (mx.y < mx.z) {
                        test.y += step.y;
                        mx.y += delta.y;
                    } else {
                        test.z += step.z;
                        mx.z += delta.z;
                    }
                }
            }
        } while(
            iteration < iterationCount &&

            test.x >= 0.0f &&
            test.y >= 0.0f &&
            test.z >= 0.0f &&

            test.x < float(resX) &&
            test.y < float(resX) &&
            test.z < float(resX)
        );
    }

    return lastRes;
}






uniform uint materialID;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform mat4 transform;
uniform mat4 transformInv;

void main()
{
    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);

        Ray ray = fetchFirstRay(t);
        uint count = texelInfo[t].count;
        for(uint i=0;i<count;i++){
            if(ray.actived > 0 && ray.params.y < ray.params.z){
                Hit hit = hits[ray.hit];

                vec3 p0 = ray.origin;
                vec3 p1 = ray.origin + ray.direct;
                vec3 p0t = (transformInv * vec4(ray.origin, 1.0)).xyz;
                vec3 p1t = (transformInv * vec4(ray.origin + ray.direct, 1.0)).xyz;

                Ray tray = ray;
                tray.origin = p0t;
                tray.direct = p1t - p0t;
                float rate = lengthFast(tray.direct) / lengthFast(ray.direct);
                tray.direct /= rate;

                TResult res = traverse(tray.origin, tray.direct);
                float dst = res.dist / rate;
                if(dst < hit.dist){
                    Hit newHit = hit;
                    newHit.dist = dst;
                    newHit.normal = (vec4(res.normal, 0.0) * transformInv).xyz;
                    newHit.triangle = res.triangle;
                    if(res.materialID >= 0){
                        newHit.materialID = uint(res.materialID) + materialID;
                    } else {
                        newHit.materialID = materialID;
                    }
                    newHit.texcoord = res.texcoord;
                    newHit.tangent = (vec4(res.tangent, 0.0) * transformInv).xyz;
                    storeHit(ray, newHit);
                }
            }

            ray = fetchNextRay(ray);
        }
    }
}