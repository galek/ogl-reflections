#version 450 core

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

struct Ray {
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec2 texcoord;
    vec4 params;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};

uniform mat4 projInv;
uniform mat4 camInv;
uniform vec2 sceneRes;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform float reflectionRate;
uniform uint materialID;

uniform sampler2D tex;

void main()
{
    const vec3 light = vec3(0.0f, 10.0f, 0.0f);

    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);
        Hit hit = hits[t];
        if(hit.materialID == materialID){
            Ray ray = rays[t];

            if(ray.actived > 0 && hit.params.x < 1.0f && ray.params.y < 2.0f){
                Ray newRay = ray;
                newRay.origin += newRay.direct * hit.dist;

                vec3 normal = -normalize(hit.normal * dot(hit.normal, newRay.direct));
                float light = dot(normalize(light - newRay.origin), normal) * 0.5 + 0.5;

                vec4 tx = texture(tex, hit.texcoord);
                vec3 color = /*vec3(0.9f, 0.5f, 0.5f) **/ tx.rgb * tx.a * light;

                if(tx.a > 0.5f){
                    newRay.final = mix(newRay.final, color, newRay.params.x);
                    newRay.direct = normalize(reflect(newRay.direct, normal));
                    newRay.params.x = reflectionRate;
                    newRay.params.y += 1.0f;
                }

                newRay.origin += normalize(normal * dot(newRay.direct, normal)) * 0.01f;

                hit.params.x = 1.0f;
                hits[t] = hit;
                rays[t] = newRay;
            }
        }
    }
}