#version 450 core

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

float lengthFast(in vec3 v){
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

vec3 normalizeFast(in vec3 v){
    return v / lengthFast(v);
}

/* ============ RAYS ============= */

struct Ray {
    uint previous;
    uint hit;
    uint shadow;
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
    vec4 params0;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 params;
};

struct Texel {
    uint last;
    uint count;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};
layout(std430, binding=10) buffer s_texels {Texel texelInfo[];};
layout (binding=0) uniform atomic_uint rcounter;
layout (binding=1) uniform atomic_uint hcounter;

uint createRay(in Ray original){
    uint hidx = atomicCounterIncrement(hcounter);
    uint ridx = atomicCounterIncrement(rcounter);
    Ray ray = original;
    ray.hit = hidx;
    Hit hit;
    hit.dist = 100000.0f;
    hit.triangle = LONGEST;
    hit.materialID = LONGEST;
    hits[hidx] = hit;
    rays[ridx] = ray;
    return ridx;
}

uint createRay(){
    Ray newRay;
    return createRay(newRay);
}

void storeTexel(in uint texel, in uint rayIndex){
    rays[rayIndex].previous = atomicExchange(texelInfo[texel].last, rayIndex);
    atomicAdd(texelInfo[texel].count, 1);
}

void storeRay(in uint rayIndex, in Ray ray){
    rays[rayIndex].direct = ray.direct;
    rays[rayIndex].origin = ray.origin;
    rays[rayIndex].actived = ray.actived;
    rays[rayIndex].color = ray.color;
    rays[rayIndex].final = ray.final;
    rays[rayIndex].params = ray.params;
    rays[rayIndex].params0 = ray.params0;
    rays[rayIndex].shadow = ray.shadow;
}

void storeHit(in Ray ray, in Hit hit){
    hits[ray.hit].dist = hit.dist;
    hits[ray.hit].triangle = hit.triangle;
    hits[ray.hit].normal = hit.normal;
    hits[ray.hit].texcoord = hit.texcoord;
    hits[ray.hit].tangent = hit.tangent;
    hits[ray.hit].materialID = hit.materialID;
    hits[ray.hit].params = hit.params;
}

Ray fetchFirstRay(in uint texel){
    return rays[texelInfo[texel].last];
}

Ray fetchNextRay(in Ray ray){
    return rays[ray.previous];
}

/* ============ END =========== */

uniform mat4 projInv;
uniform mat4 camInv;
uniform vec2 sceneRes;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform float reflectionRate;
uniform uint materialID;

uniform sampler2D tex;
uniform sampler2D bump;
uniform sampler2D spec;

vec3 getNormalMapping(vec2 texcoordi){
    vec2 textures = textureSize(bump, 0);
    vec2 texcoord = texcoordi;//(floor(texcoordi * textures) + 0.5f) / textures;
    float val = texture(bump, texcoord).r;
    float valX = texture(bump, texcoord + vec2(1.0f / textures.x, 0.0f) * 1.0f).r;
    float valY = texture(bump, texcoord + vec2(0.0f, 1.0f / textures.y) * 1.0f).r;
    vec3 h = vec3(1.0f,0.0f,val - valX);
    vec3 v = vec3(0.0f,1.0f,val - valY);
    return normalizeFast(cross(h,v));
}



vec3 generate_cubemap_coord(in vec2 txc, in int face)
{
    vec3 v;
    switch(face)
    {
        case 0: v = vec3( 1.0, -txc.y, -txc.x); break; // +X
        case 1: v = vec3(-1.0, -txc.y,  txc.x); break; // -X
        case 2: v = vec3( txc.x,  1.0,  txc.y); break; // +Y
        case 3: v = vec3( txc.x, -1.0, -txc.y); break; // -Y
        case 4: v = vec3( txc.x, -txc.y,  1.0); break; // +Z
        case 5: v = vec3(-txc.x, -txc.y, -1.0); break; // -Z
    }
    return normalizeFast(v);
}

vec3 get_coord(in vec3 v)
{
    const float d45 = 0.9999f;//0.70710678118f;
    float mx = max(abs(v.x), max(abs(v.y), abs(v.z)));
    vec3 vv = v / mx;
    vec3 vn = normalizeFast(v);
    vec3 f;
    if(dot(vv, vec3( 1.0,  0.0, 0.0)) > d45) f = vec3( -vv.z, -vv.y, 0.0f);
    if(dot(vv, vec3(-1.0,  0.0, 0.0)) > d45) f = vec3(  vv.z,  -vv.y, 1.0f);
    if(dot(vv, vec3( 0.0,  1.0, 0.0)) > d45) f = vec3(  vv.x,  vv.z, 2.0f);
    if(dot(vv, vec3( 0.0, -1.0, 0.0)) > d45) f = vec3(  vv.x,  -vv.z, 3.0f);
    if(dot(vv, vec3( 0.0,  0.0, 1.0)) > d45) f = vec3(   vv.x, -vv.y, 4.0f);
    if(dot(vv, vec3( 0.0,  0.0, -1.0)) > d45) f = vec3( -vv.x, -vv.y, 5.0f);
    return vec3(f.xy * 0.5 + 0.5, f.z);
}



uniform vec3 light;

void main()
{
    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);
        uint count = texelInfo[t].count;
        uint last = texelInfo[t].last;
        for(uint i=0;i<count;i++){
            Ray ray = rays[last];
            if(ray.actived > 0 && ray.params.w < 1.0f && ray.params.y < ray.params.z){
                Hit hit = hits[ray.hit];
                if(hit.materialID == materialID && hit.dist < 10000.0f){
                    vec4 tx = texture(tex, hit.texcoord);

                    Ray newRay = ray;
                    //newRay.actived = 1;
                    newRay.params.w = 1.0f;
                    newRay.origin += newRay.direct * hit.dist;

                    vec3 binormal = normalizeFast(cross(hit.tangent, hit.normal));
                    mat3 tbn = transpose(mat3(hit.tangent, binormal, hit.normal));

                    vec3 prenormal = hit.normal;
                    prenormal = normalizeFast(getNormalMapping(hit.texcoord) * tbn);

                    vec3 normal = -normalizeFast(prenormal * dot(prenormal, newRay.direct));

                    float light = clamp(dot(normalizeFast(light - newRay.origin), normal), 0.0f, 1.0f);
                    vec3 color = tx.rgb * light;

                    float spc = texture(spec, hit.texcoord).r * reflectionRate;
                    if(tx.a > 0.999f){
                        newRay.final = mix(newRay.final, color, newRay.params.x);
                        newRay.direct = normalizeFast(reflect(newRay.direct, normal));
                        newRay.params.x *= spc;
                        newRay.params.y += 1.0f;
                        if(spc < 0.001f) {
                            newRay.actived = 0;
                        }
                    }

                    newRay.origin += normalizeFast(normal * dot(newRay.direct, normal)) * 0.001f;
                    storeRay(last, newRay);

/*
                    uint ridx = createRay(newRay);
                    storeTexel(t, ridx);
                    storeHit(rays[ridx], hit);

                    ray.params0.x = 0.0f;
                    ray.actived = 0;
                    storeRay(last, ray);*/
                }
            }
            last = ray.previous;
        }
    }
}