#version 450 core

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

float lengthFast(in vec3 v){
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

vec3 normalizeFast(in vec3 v){
    return v / lengthFast(v);
}

/* ============ RAYS ============= */

struct Ray {
    uint previous;
    uint hit;
    uint shadow;
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
    vec4 params0;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 params;
};

struct Texel {
    uint last;
    uint count;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};
layout(std430, binding=10) buffer s_texels {Texel texelInfo[];};
layout (binding=0) uniform atomic_uint rcounter;
layout (binding=1) uniform atomic_uint hcounter;

uint createRay(in Ray original){
    uint hidx = atomicCounterIncrement(hcounter);
    uint ridx = atomicCounterIncrement(rcounter);
    Ray ray = original;
    ray.previous = LONGEST;
    ray.hit = hidx;
    ray.shadow = LONGEST;
    Hit hit;
    hit.dist = 100000.0f;
    hit.triangle = LONGEST;
    hit.materialID = LONGEST;
    hits[hidx] = hit;
    rays[ridx] = ray;
    return ridx;
}

uint createRay(){
    Ray newRay;
    return createRay(newRay);
}

void storeTexel(in uint texel, in uint rayIndex){
    rays[rayIndex].previous = atomicExchange(texelInfo[texel].last, rayIndex);
    atomicAdd(texelInfo[texel].count, 1);
}

void storeRay(in uint rayIndex, in Ray ray){
    rays[rayIndex].direct = ray.direct;
    rays[rayIndex].origin = ray.origin;
    rays[rayIndex].actived = ray.actived;
    rays[rayIndex].color = ray.color;
    rays[rayIndex].final = ray.final;
    rays[rayIndex].params = ray.params;
    rays[rayIndex].params0 = ray.params0;
    rays[rayIndex].shadow = ray.shadow;
}

void storeHit(in Ray ray, in Hit hit){
    hits[ray.hit].dist = hit.dist;
    hits[ray.hit].triangle = hit.triangle;
    hits[ray.hit].normal = hit.normal;
    hits[ray.hit].texcoord = hit.texcoord;
    hits[ray.hit].tangent = hit.tangent;
    hits[ray.hit].materialID = hit.materialID;
    hits[ray.hit].params = hit.params;
}

Ray fetchFirstRay(in uint texel){
    return rays[texelInfo[texel].last];
}

Ray fetchNextRay(in Ray ray){
    return rays[ray.previous];
}

/* ============ END =========== */

uniform mat4 projInv;
uniform mat4 camInv;
uniform vec2 sceneRes;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform float reflectionRate;
uniform uint materialID;

uniform sampler2D tex;
uniform sampler2D bump;
uniform sampler2D spec;

vec3 getNormalMapping(vec2 texcoordi){
    vec2 textures = textureSize(bump, 0);
    vec2 texcoord = texcoordi;//(floor(texcoordi * textures) + 0.5f) / textures;
    float val = texture(bump, texcoord).r;
    float valX = texture(bump, texcoord + vec2(1.0f / textures.x, 0.0f) * 1.0f).r;
    float valY = texture(bump, texcoord + vec2(0.0f, 1.0f / textures.y) * 1.0f).r;
    vec3 h = vec3(1.0f,0.0f,val - valX);
    vec3 v = vec3(0.0f,1.0f,val - valY);
    return normalizeFast(cross(h,v));
}



vec3 generate_cubemap_coord(in vec2 txc, in int face)
{
    vec3 v;
    switch(face)
    {
        case 0: v = vec3( 1.0, -txc.y, -txc.x); break; // +X
        case 1: v = vec3(-1.0, -txc.y,  txc.x); break; // -X
        case 2: v = vec3( txc.x,  1.0,  txc.y); break; // +Y
        case 3: v = vec3( txc.x, -1.0, -txc.y); break; // -Y
        case 4: v = vec3( txc.x, -txc.y,  1.0); break; // +Z
        case 5: v = vec3(-txc.x, -txc.y, -1.0); break; // -Z
    }
    return normalizeFast(v);
}

vec3 get_coord(in vec3 v)
{
    const float d45 = 0.9999f;//0.70710678118f;
    float mx = max(abs(v.x), max(abs(v.y), abs(v.z)));
    vec3 vv = v / mx;
    vec3 vn = normalizeFast(v);
    vec3 f;
    if(dot(vv, vec3( 1.0,  0.0, 0.0)) > d45) f = vec3( -vv.z, -vv.y, 0.0f);
    if(dot(vv, vec3(-1.0,  0.0, 0.0)) > d45) f = vec3(  vv.z,  -vv.y, 1.0f);
    if(dot(vv, vec3( 0.0,  1.0, 0.0)) > d45) f = vec3(  vv.x,  vv.z, 2.0f);
    if(dot(vv, vec3( 0.0, -1.0, 0.0)) > d45) f = vec3(  vv.x,  -vv.z, 3.0f);
    if(dot(vv, vec3( 0.0,  0.0, 1.0)) > d45) f = vec3(   vv.x, -vv.y, 4.0f);
    if(dot(vv, vec3( 0.0,  0.0, -1.0)) > d45) f = vec3( -vv.x, -vv.y, 5.0f);
    return vec3(f.xy * 0.5 + 0.5, f.z);
}

float computeFresnel(in vec3 normal, in vec3 incident, in vec3 transmissionDirection, in float refractiveIndexIncident, in float refractiveIndexTransmitted) {
	float cosThetaIncident = dot(normal, incident);
	float cosThetaTransmitted = dot(normal, transmissionDirection);
	float reflectionCoefficientSPolarized = pow((refractiveIndexIncident * cosThetaIncident - refractiveIndexTransmitted * cosThetaTransmitted)   /   (refractiveIndexIncident * cosThetaIncident + refractiveIndexTransmitted * cosThetaTransmitted)   , 2);
    float reflectionCoefficientPPolarized = pow((refractiveIndexIncident * cosThetaTransmitted - refractiveIndexTransmitted * cosThetaIncident)   /   (refractiveIndexIncident * cosThetaTransmitted + refractiveIndexTransmitted * cosThetaIncident)   , 2);
	float reflectionCoefficientUnpolarized = (reflectionCoefficientSPolarized + reflectionCoefficientPPolarized) / 2.0; // Equal mix.
	return clamp(reflectionCoefficientUnpolarized, 0.0f, 1.0f);
}

uniform vec3 light;





uniform float time;

uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}

float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

uint counter = 0;
float random(){
    float r = random(vec3(gl_GlobalInvocationID.xy, time + counter));
    counter++;
    return r;
}

#define PI                    3.1415926535897932384626422832795028841971
#define TWO_PI				  6.2831853071795864769252867665590057683943
#define SQRT_OF_ONE_THIRD     0.5773502691896257645091487805019574556476
#define E                     2.7182818284590452353602874713526624977572

vec3 randomCosine(in vec3 normal) {
    float up = sqrt(random()); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = random() * TWO_PI;

	vec3 directionNotNormal;
	if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
		directionNotNormal = vec3(1, 0, 0);
	} else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
		directionNotNormal = vec3(0, 1, 0);
	} else {
		directionNotNormal = vec3(0, 0, 1);
	}
	vec3 perpendicular1 = normalize( cross(normal, directionNotNormal) );
	vec3 perpendicular2 =            cross(normal, perpendicular1);
    return ( up * normal ) + ( cos(around) * over * perpendicular1 ) + ( sin(around) * over * perpendicular2 );
}

#define DIFFUSE
#define DIFFUSE_COUNT 2
#define REFLECTION

void main()
{
    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);
        uint count = texelInfo[t].count;
        uint last = texelInfo[t].last;
        for(uint i=0;i<count;i++){
            Ray ray = rays[last];
            if(ray.actived > 0 && ray.params.w < 1.0f && ray.params.y < ray.params.z){
                Hit hit = hits[ray.hit];
                if(hit.materialID == materialID && hit.dist < 10000.0f){
                    vec4 tx = texture(tex, hit.texcoord);

                    Ray newRay = ray;
                    newRay.params.w = 1.0f;
                    newRay.origin += newRay.direct * hit.dist;

                    vec3 binormal = normalizeFast(cross(hit.tangent, hit.normal));
                    mat3 tbn = transpose(mat3(hit.tangent, binormal, hit.normal));

                    vec3 prenormal = hit.normal;
                    prenormal = normalizeFast(getNormalMapping(hit.texcoord) * tbn);

                    vec3 normal = -normalizeFast(prenormal * dot(prenormal, newRay.direct));
                    vec3 color = tx.rgb;

                    float iorIn = 1.0f;
                    float iorOut = 1.66f;

                    bool cond = dot(prenormal, newRay.direct) <= 0;
                    float coef = cond ? iorIn / iorOut : iorOut / iorIn;
                    vec3 refr = normalizeFast(refract(newRay.direct, normal, coef));
                    vec3 refl = normalizeFast(reflect(newRay.direct, normal));
                    float fres = computeFresnel(
                        normal,
                        newRay.direct,
                        refr,
                        cond ? iorIn : iorOut,
                        cond ? iorOut : iorIn
                    );

                    float spc = newRay.params.x * texture(spec, hit.texcoord).r * reflectionRate * fres / tx.a;

                    tx.a *= dot(newRay.direct, prenormal) <= 0.0f ? 1.0f : 0.0f;
                    if(tx.a >= 0.001f){
                        float samp = 1.0f;

#ifdef REFLECTION
                        samp *= 1.0f - spc;
                        if(spc >= 0.001f){
                            Ray newRay2 = newRay;
                            newRay2.direct = refl;
                            newRay2.color *= spc;
                            newRay2.params0.y *= spc;
                            newRay2.params.y += 1.0f;
                            newRay2.origin += normalizeFast(normal * dot(newRay2.direct, normal)) * 0.1f;
                            uint idx = createRay(newRay2);
                            storeHit(rays[idx], hit);
                            storeTexel(t, idx);
                        }
#endif

#ifdef DIFFUSE
                        samp *= 1.0f / DIFFUSE_COUNT * tx.a;
                        if(samp >= 0.001f){
                            for(int i=0;i<DIFFUSE_COUNT;i++){
                                Ray newRay2 = newRay;
                                newRay2.direct = randomCosine(normal);
                                newRay2.color *= color * samp;
                                newRay2.params0.y *= samp;
                                newRay2.params.y += 1.0f;
                                newRay2.origin += normalizeFast(normal * dot(newRay2.direct, normal)) * 0.1f;
                                uint idx = createRay(newRay2);
                                storeHit(rays[idx], hit);
                                storeTexel(t, idx);
                            }
                        }
#endif

#ifdef REFRACTIVE
                        float ref = 1.0f - samp;
                        if(ref >= 0.001f){
                            Ray newRay2 = newRay;
                            newRay2.direct = refr;
                            newRay2.color *= ref;
                            newRay2.params0.y *= ref;
                            newRay2.params.y += 1.0f;
                            newRay2.origin += normalizeFast(normal * dot(newRay2.direct, normal)) * 0.1f;
                            uint idx = createRay(newRay2);
                            storeHit(rays[idx], hit);
                            storeTexel(t, idx);
                        }
#endif
                        newRay.actived = 0;
                    }
                    newRay.color *= 1.0f - tx.a;
                    newRay.params0.y *= 1.0f - tx.a;
                    newRay.params.y += 1.0f;
                    newRay.origin += normalizeFast(normal * dot(newRay.direct, normal)) * 0.1f;
                    storeRay(last, newRay);
                }
            }
            last = ray.previous;
        }
    }
}