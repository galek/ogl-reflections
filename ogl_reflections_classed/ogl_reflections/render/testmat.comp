#version 450 core

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

struct Ray {
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 params;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};

uniform mat4 projInv;
uniform mat4 camInv;
uniform vec2 sceneRes;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

uniform float reflectionRate;
uniform uint materialID;

uniform sampler2D tex;
uniform sampler2D bump;
uniform sampler2D spec;

vec3 getNormalMapping(vec2 texcoordi){
    vec2 textures = textureSize(bump, 0);
    vec2 texcoord = texcoordi;//(floor(texcoordi * textures) + 0.5f) / textures;
    float val = texture(bump, texcoord).r;
    float valX = texture(bump, texcoord + vec2(1.0f / textures.x, 0.0f) * 1.0f).r;
    float valY = texture(bump, texcoord + vec2(0.0f, 1.0f / textures.y) * 1.0f).r;
    vec3 h = vec3(1.0f,0.0f,val - valX);
    vec3 v = vec3(0.0f,1.0f,val - valY);
    return normalize(cross(h,v));
}

void main()
{
    const vec3 light = vec3(0.0f, 100.0f, 0.0f);

    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);
        Hit hit = hits[t];
        if(hit.materialID == materialID){
            Ray ray = rays[t];

            if(ray.actived > 0 && hit.params.x < 1.0f && ray.params.y < ray.params.z){
                Ray newRay = ray;
                newRay.origin += newRay.direct * hit.dist;

                vec3 binormal = normalize(cross(hit.tangent, hit.normal));
                mat3 tbn = transpose(mat3(hit.tangent, binormal, hit.normal));

                vec3 prenormal = hit.normal;
                prenormal = normalize(getNormalMapping(hit.texcoord) * tbn);

                vec3 normal = -normalize(prenormal * dot(prenormal, newRay.direct));
                float light = dot(normalize(light - newRay.origin), normal);


                vec4 tx = texture(tex, hit.texcoord);
                vec3 color =
                //vec3(texture(bump, hit.texcoord).r) *
                tx.rgb * tx.a *
                //vec3(hit.texcoord, 0.0f)*
                light;


                float spc = texture(spec, hit.texcoord).r * 0.5f;
                if(tx.a > 0.01f){
                    newRay.final = mix(newRay.final, color, newRay.params.x);
                    newRay.direct = normalize(reflect(newRay.direct, normal));
                    newRay.params.x = spc;
                    newRay.params.y += 1.0f;
                    if(spc < 0.001f) newRay.actived = 0;
                }

                newRay.origin += normalize(normal * dot(newRay.direct, normal)) * 0.01f;
                //newRay.final = prenormal * 0.5 + 0.5;

                hit.params.x = 1.0f;
                hits[t] = hit;
                rays[t] = newRay;
            }
        }
    }
}