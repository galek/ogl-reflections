#version 450 core

struct Voxel {
    uint parent;
	uint last;
    uint count;
    uint coordX;
    uint coordY;
    uint coordZ;
};

layout(std430, binding=0) buffer s_voxels {Voxel voxels[];};
layout(std430, binding=1) buffer s_voxels_sub {uint voxels_subgrid[];};
layout(std430, binding=3) buffer s_vbo {float sverts[];};
layout(std430, binding=4) buffer s_ebo {uint indics[];};
layout(std430, binding=5) buffer s_to_helper {uint to_helper[];};
layout(std430, binding=6) buffer s_from_helper {uint from_helper[];};

layout (binding=0) uniform atomic_uint scounter;
layout (binding=2) uniform atomic_uint lscounter_to;
layout (binding=3) uniform atomic_uint lscounter_from;

uniform uint currentDepth;
uniform uint maxDepth;
uniform vec3 offset;
uniform vec3 scale;

const uint LONGEST = 0xFFFFFFFF;

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint idx = gl_GlobalInvocationID.x;
    uint resX = uint(pow(2, currentDepth));

    if(currentDepth == 0) {
        if(idx == 0){
            uint hloc = atomicCounterIncrement(lscounter_to);
            to_helper[hloc] = 0;
            Voxel voxel;
            voxel.last = LONGEST;
            voxel.count = 0;
            voxel.coordX = 0;
            voxel.coordY = 0;
            voxel.coordZ = 0;
            voxel.parent = LONGEST;

            uint loc = atomicCounterIncrement(scounter);
            voxels[loc] = voxel;
        }
    } else {
        uint spr = idx / 8;
        if(spr < atomicCounter(lscounter_from)){
            uint parent = from_helper[spr];

            uint loc = idx % 8;
            uint w = loc % 2;
            uint h = (loc / 2) % 2;
            uint d = loc / 4;
            uvec3 co = uvec3(w, h, d);

            Voxel voxel = voxels[parent];
            voxels_subgrid[parent * 8 + loc] = 0xFFFFFFFF;
            if(voxel.count > 0){
                uvec3 parentSpace = uvec3(voxel.coordX, voxel.coordY, voxel.coordZ);
                uvec3 globalSpace = parentSpace * 2 + co;

                Voxel newVoxel;
                newVoxel.parent = parent;
                newVoxel.coordX = globalSpace.x;
                newVoxel.coordY = globalSpace.y;
                newVoxel.coordZ = globalSpace.z;
                newVoxel.count = 0;
                newVoxel.last = LONGEST;

                uint vloc = atomicCounterIncrement(scounter);
                uint hloc = atomicCounterIncrement(lscounter_to);
                to_helper[hloc] = vloc;

                voxels[vloc] = newVoxel;
                voxels_subgrid[parent * 8 + loc] = vloc;
            }
        }
    }
}