#version 450 core

struct Thash {
	uint triangle;
	uint previous;
};

struct Voxel {
	uint last;
    uint count;
    uint coordX;
    uint coordY;
    uint coordZ;
};

layout(std430, binding=0) buffer s_voxels {Voxel voxels[];};
layout(std430, binding=1) buffer s_voxels_sub {uint voxels_subgrid[];};
layout(std430, binding=2) buffer s_thashes {Thash thashes[];};
layout(std430, binding=3) buffer s_vbo {float verts[];};
layout(std430, binding=4) buffer s_ebo {uint indics[];};
layout(std430, binding=5) buffer s_to_helper {uint to_helper[];};
layout(std430, binding=6) buffer s_from_helper {uint from_helper[];};

layout (binding=0) uniform atomic_uint vcounter;
layout (binding=1) uniform atomic_uint scounter;
layout (binding=2) uniform atomic_uint lscounter_to;
layout (binding=3) uniform atomic_uint lscounter_from;

uniform uint currentDepth;
uniform uint maxDepth;
uniform vec3 offset;
uniform vec3 scale;

const uint LONGEST = 0xFFFFFFFF;

#define FINDMINMAX(x0,x1,x2,min,max) \
  min = max = x0;   \
  if(x1<min) min=x1;\
  if(x1>max) max=x1;\
  if(x2<min) min=x2;\
  if(x2>max) max=x2;

int planeBoxOverlap(in vec3 normal, in vec3 vert, in vec3 maxbox)
{
    int q;
    vec3 vmin,vmax;

    vmin = mix( maxbox - vert, -maxbox - vert, sign(normal) * 0.5f + 0.5f);
    vmax = mix(-maxbox - vert,  maxbox - vert, sign(normal) * 0.5f + 0.5f);

    if(dot(normal,vmin)>0.0f) return 0;
    if(dot(normal,vmax)>=0.0f) return 1;
    return 0;
}

#define AXISTEST_X01(a, b, fa, fb)			   \
	p0 = a*v0.y - b*v0.z;			       	   \
	p2 = a*v2.y - b*v2.z;			       	   \
        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
	rad = fa * boxhalfsize.y + fb * boxhalfsize.z;   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_X2(a, b, fa, fb)			   \
	p0 = a*v0.y - b*v0.z;			           \
	p1 = a*v1.y - b*v1.z;			       	   \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize.y + fb * boxhalfsize.z;   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Y02(a, b, fa, fb)			   \
	p0 = -a*v0.x + b*v0.z;		      	   \
	p2 = -a*v2.x + b*v2.z;	       	       	   \
        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
	rad = fa * boxhalfsize.x + fb * boxhalfsize.z;   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Y1(a, b, fa, fb)			   \
	p0 = -a*v0.x + b*v0.z;		      	   \
	p1 = -a*v1.x + b*v1.z;	     	       	   \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize.x + fb * boxhalfsize.z;   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Z12(a, b, fa, fb)			   \
	p1 = a*v1.x - b*v1.y;			           \
	p2 = a*v2.x - b*v2.y;			       	   \
        if(p2<p1) {min=p2; max=p1;} else {min=p1; max=p2;} \
	rad = fa * boxhalfsize.x + fb * boxhalfsize.y;   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Z0(a, b, fa, fb)			   \
	p0 = a*v0.x - b*v0.y;				   \
	p1 = a*v1.x - b*v1.y;			           \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize.x + fb * boxhalfsize.y;   \
	if(min>rad || max<-rad) return 0;

int triBoxOverlap(in vec3 boxcenter, in vec3 boxhalfsize, in vec3 triverts[3]){
   vec3 v0,v1,v2;
   float min,max,p0,p1,p2,rad,fex,fey,fez;
   vec3 normal,e0,e1,e2;

   v0 = triverts[0] - boxcenter;
   v1 = triverts[1] - boxcenter;
   v2 = triverts[2] - boxcenter;

   e0= v1-v0;
   e1= v2-v1;
   e2= v0-v2;

   fex = abs(e0.x);
   fey = abs(e0.y);
   fez = abs(e0.z);

   AXISTEST_X01(e0.z, e0.y, fez, fey);
   AXISTEST_Y02(e0.z, e0.x, fez, fex);
   AXISTEST_Z12(e0.y, e0.x, fey, fex);

   fex = abs(e1.x);
   fey = abs(e1.y);
   fez = abs(e1.z);

   AXISTEST_X01(e1.z, e1.y, fez, fey);
   AXISTEST_Y02(e1.z, e1.x, fez, fex);
   AXISTEST_Z0(e1.y, e1.x, fey, fex);

   fex = abs(e2.x);
   fey = abs(e2.y);
   fez = abs(e2.z);

   AXISTEST_X2(e2.z, e2.y, fez, fey);
   AXISTEST_Y1(e2.z, e2.x, fez, fex);
   AXISTEST_Z12(e2.y, e2.x, fey, fex);

   FINDMINMAX(v0.x,v1.x,v2.x,min,max);
   if(min>boxhalfsize.x || max<-boxhalfsize.x) return 0;

   FINDMINMAX(v0.y,v1.y,v2.y,min,max);
   if(min>boxhalfsize.y || max<-boxhalfsize.y) return 0;

   FINDMINMAX(v0.z,v1.z,v2.z,min,max);
   if(min>boxhalfsize.z || max<-boxhalfsize.z) return 0;

   normal = cross(e0,e1);
   if(planeBoxOverlap(normal,v0,boxhalfsize) < 1) return 0;
   return 1;
}


layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint idx = gl_GlobalInvocationID.x;
    uint resX = uint(pow(2, currentDepth));

    if(currentDepth == 0) {
        if(idx == 0){
            uint hloc = atomicCounterIncrement(lscounter_to);
            to_helper[hloc] = 0;
            Voxel voxel;
            voxel.last = LONGEST;
            voxel.count = 0;
            voxel.coordX = 0;
            voxel.coordY = 0;
            voxel.coordZ = 0;

            uint loc = atomicCounterIncrement(scounter);
            voxels[loc] = voxel;
        }
    } else {
        uint spr = idx / 8;
        if(spr < atomicCounter(lscounter_from)){
            uint parent = from_helper[spr];

            uint loc = idx % 8;
            uint w = loc % 2;
            uint h = (loc / 2) % 2;
            uint d = loc / 4;
            uvec3 co = uvec3(w, h, d);

            Voxel voxel = voxels[parent];
            voxels_subgrid[parent * 8 + loc] = 0xFFFFFFFF;
            if(voxel.count > 0){
                uvec3 parentSpace = uvec3(voxel.coordX, voxel.coordY, voxel.coordZ);
                uvec3 globalSpace = parentSpace * 2 + co;

                vec3 norm = vec3(globalSpace) + 0.5f;

                uint triangleCount = 300000;
                Thash hash = thashes[voxel.last];
                bool needsSkip = false;
                uint cnt = min(voxel.count, triangleCount);

                /*
                for(uint i=0;i<cnt;i++){
                    if(!needsSkip){
                        vec3 trivert[3];

                        uint tri = hash.triangle;
                        for (int x = 0; x < 3; x++) {
                            uint j = indics[tri * 3 + x];
                            vec3 pos = vec3(verts[j * 3 + 0], verts[j * 3 + 1], verts[j * 3 + 2]);
                            pos -= offset;
                            pos /= scale;
                            pos *= resX;
                            trivert[x] = pos;
                        }

                        if(triBoxOverlap(norm, vec3(0.5), trivert) == 1){*/
                            Voxel newVoxel;
                            newVoxel.coordX = globalSpace.x;
                            newVoxel.coordY = globalSpace.y;
                            newVoxel.coordZ = globalSpace.z;
                            newVoxel.count = 0;
                            newVoxel.last = LONGEST;

                            uint vloc = atomicCounterIncrement(scounter);
                            uint hloc = atomicCounterIncrement(lscounter_to);
                            to_helper[hloc] = vloc;

                            voxels[vloc] = newVoxel;
                            voxels_subgrid[parent * 8 + loc] = vloc;

                            needsSkip = true;
                        /*
                        }
                        uint previous = hash.previous;
                        if(previous != LONGEST){
                            hash = thashes[previous];
                        } else {
                            needsSkip = true;
                        }
                    } else {
                        break;
                    }
                }*/
            }
        }
    }
}