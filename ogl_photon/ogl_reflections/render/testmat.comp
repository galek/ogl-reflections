#version 450 core

const uint LONGEST = 0xFFFFFFFF;
const float INFINITY = 1e10;

float lengthFast(in vec3 v){
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

vec3 normalizeFast(in vec3 v){
    return v / lengthFast(v);
}

/* ============ RAYS ============= */

struct Ray {
    uint previous;
    uint hit;
    uint shadow;
    int actived;
    vec3 origin;
    vec3 direct;
    vec3 color;
    vec3 final;
    vec4 params;
    vec4 params0;
};

struct Hit {
    float dist;
    uint triangle;
    uint materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 params;
};

struct Texel {
    uint last;
    uint count;
};

layout(std430, binding=8) buffer s_rays {Ray rays[];};
layout(std430, binding=9) buffer s_hits {Hit hits[];};
layout(std430, binding=10) buffer s_texels {Texel texelInfo[];};
layout (binding=0) uniform atomic_uint rcounter;
layout (binding=1) uniform atomic_uint hcounter;

uint createRay(in Ray original){
    uint hidx = atomicCounterIncrement(hcounter);
    uint ridx = atomicCounterIncrement(rcounter);
    Ray ray = original;
    ray.hit = hidx;
    Hit hit;
    hit.dist = 100000.0f;
    hit.triangle = LONGEST;
    hit.materialID = LONGEST;
    hits[hidx] = hit;
    rays[ridx] = ray;
    return ridx;
}

uint createRay(){
    Ray newRay;
    return createRay(newRay);
}

void storeTexel(in uint texel, in uint rayIndex){
    rays[rayIndex].previous = atomicExchange(texelInfo[texel].last, rayIndex);
    atomicAdd(texelInfo[texel].count, 1);
}

void storeRay(in uint rayIndex, in Ray ray){
    rays[rayIndex].direct = ray.direct;
    rays[rayIndex].origin = ray.origin;
    rays[rayIndex].actived = ray.actived;
    rays[rayIndex].color = ray.color;
    rays[rayIndex].final = ray.final;
    rays[rayIndex].params = ray.params;
    rays[rayIndex].params0 = ray.params0;
    rays[rayIndex].shadow = ray.shadow;
}

void storeHit(in Ray ray, in Hit hit){
    hits[ray.hit].dist = hit.dist;
    hits[ray.hit].triangle = hit.triangle;
    hits[ray.hit].normal = hit.normal;
    hits[ray.hit].texcoord = hit.texcoord;
    hits[ray.hit].tangent = hit.tangent;
    hits[ray.hit].materialID = hit.materialID;
    hits[ray.hit].params = hit.params;
}

Ray fetchFirstRay(in uint texel){
    return rays[texelInfo[texel].last];
}

Ray fetchNextRay(in Ray ray){
    return rays[ray.previous];
}

/* ============ END =========== */

struct Thash {
	vec3 color;
    vec3 position;
    vec3 normal;
    uint previous;
};

struct Voxel {
    uint parent;
	uint last;
    uint count;
    uint coordX;
    uint coordY;
    uint coordZ;
};

layout(std430, binding=0) buffer s_voxels {Voxel voxels[];};
layout(std430, binding=1) buffer s_voxels_sub {uint voxels_subgrid[];};
layout(std430, binding=2) buffer s_thashes {Thash thashes[];};

uniform uint maxDepth;
uniform vec3 offset;
uniform vec3 scale;

uniform uint photonCount;

uint cnv_subgrid(uint sub, uvec3 idu){
    return sub * 8 + (idu.x + idu.y * 2 + idu.z * 4);
}

uint searchVoxelIndex(uvec3 idx, uint maxDepth){
    uint currentDepth = maxDepth-1;
    uvec3 id = uvec3(0);
    bool fail = false;
    uint sub = 0;
    Voxel hash = voxels[sub];
    uvec3 idu = uvec3(0);
    uint grid = 0;

    int strt = int(currentDepth);
    for(int i=strt;i>=0;i--){
        if(!fail){
            id = uvec3(idx / uint(pow(2, i)));
            idu = id % uvec3(2);
            if(i == strt){
                grid = 0;
                sub = 0;
            } else {
                grid = cnv_subgrid(sub, idu);
                sub = voxels_subgrid[grid];
            }
            if(sub == LONGEST) {
                fail = true;
            } else {
                hash = voxels[sub];
            }
        } else {
            break;
        }
    }

    if(!fail){
        return sub;
    }
    return LONGEST;
}

uint searchVoxelIndex(uvec3 idx){
    return searchVoxelIndex(idx, maxDepth);
}

Voxel loadVoxel(in uvec3 coord, in uint depth){
    if(coord.x != LONGEST){
        uint idx = searchVoxelIndex(coord, depth+1);
        return voxels[idx];
    } else {
        Voxel voxel;
        voxel.last = LONGEST;
        voxel.count = 0;
        return voxel;
    }
}

Voxel loadVoxel(in uvec3 coord){
    return loadVoxel(coord, maxDepth-1);
}




vec3 gather(vec3 origin, vec3 dir){
    vec3 res = vec3(pow(2, maxDepth-1));
    vec3 pos = origin;
    pos -= offset;
    pos /= scale;
    pos *= res;

    float rate = res.x / scale.x;
    vec3 npos = floor(pos);

    float rad = 2.f;
    float dist = rad * rate;
    vec3 mn = npos - ceil(dist);
    vec3 mx = npos + ceil(dist);
    ivec3 mni = ivec3(mn);
    ivec3 mxi = ivec3(mx);

    vec3 light = vec3(0.0);
    ivec3 ires = ivec3(res);

    for(int x=mni.x;x<=mxi.x;x++){
        for(int y=mni.y;y<=mxi.y;y++){
            for(int z=mni.z;z<=mxi.z;z++){
                ivec3 co = ivec3(x, y, z);
                if(
                    co.x >= 0 &&
                    co.y >= 0 &&
                    co.z >= 0 &&
                    co.x < ires.x &&
                    co.y < ires.y &&
                    co.z < ires.z
                ){
                    Voxel vox = loadVoxel(uvec3(co));
                    if(vox.count > 0){
                        Thash hash = thashes[vox.last];
                        for(uint i=0;i<min(vox.count, 400);i++){
                            if(distance(origin, hash.position) < rad && dot(hash.normal, dir) < 0.0f) {
                                light += hash.color;
                                //light += 1.0f;
                            }
                            hash = thashes[hash.previous];
                        }
                    }
                }
            }
        }
    }

    return light / photonCount * 100000.0f / pow(rad, 2.0f);
}




uniform mat4 projInv;
uniform mat4 camInv;
uniform vec2 sceneRes;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform float reflectionRate;
uniform uint materialID;

uniform sampler2D tex;
uniform sampler2D bump;
uniform sampler2D spec;

vec3 getNormalMapping(vec2 texcoordi){
    vec2 textures = textureSize(bump, 0);
    vec2 texcoord = texcoordi;//(floor(texcoordi * textures) + 0.5f) / textures;
    float val = texture(bump, texcoord).r;
    float valX = texture(bump, texcoord + vec2(1.0f / textures.x, 0.0f) * 1.0f).r;
    float valY = texture(bump, texcoord + vec2(0.0f, 1.0f / textures.y) * 1.0f).r;
    vec3 h = vec3(1.0f,0.0f,val - valX);
    vec3 v = vec3(0.0f,1.0f,val - valY);
    return normalizeFast(cross(h,v));
}



vec3 generate_cubemap_coord(in vec2 txc, in int face)
{
    vec3 v;
    switch(face)
    {
        case 0: v = vec3( 1.0, -txc.y, -txc.x); break; // +X
        case 1: v = vec3(-1.0, -txc.y,  txc.x); break; // -X
        case 2: v = vec3( txc.x,  1.0,  txc.y); break; // +Y
        case 3: v = vec3( txc.x, -1.0, -txc.y); break; // -Y
        case 4: v = vec3( txc.x, -txc.y,  1.0); break; // +Z
        case 5: v = vec3(-txc.x, -txc.y, -1.0); break; // -Z
    }
    return normalizeFast(v);
}

vec3 get_coord(in vec3 v)
{
    const float d45 = 0.9999f;//0.70710678118f;
    float mx = max(abs(v.x), max(abs(v.y), abs(v.z)));
    vec3 vv = v / mx;
    vec3 vn = normalizeFast(v);
    vec3 f;
    if(dot(vv, vec3( 1.0,  0.0, 0.0)) > d45) f = vec3( -vv.z, -vv.y, 0.0f);
    if(dot(vv, vec3(-1.0,  0.0, 0.0)) > d45) f = vec3(  vv.z,  -vv.y, 1.0f);
    if(dot(vv, vec3( 0.0,  1.0, 0.0)) > d45) f = vec3(  vv.x,  vv.z, 2.0f);
    if(dot(vv, vec3( 0.0, -1.0, 0.0)) > d45) f = vec3(  vv.x,  -vv.z, 3.0f);
    if(dot(vv, vec3( 0.0,  0.0, 1.0)) > d45) f = vec3(   vv.x, -vv.y, 4.0f);
    if(dot(vv, vec3( 0.0,  0.0, -1.0)) > d45) f = vec3( -vv.x, -vv.y, 5.0f);
    return vec3(f.xy * 0.5 + 0.5, f.z);
}

float computeFresnel(in vec3 normal, in vec3 incident, in vec3 transmissionDirection, in float refractiveIndexIncident, in float refractiveIndexTransmitted) {
	float cosThetaIncident = dot(normal, incident);
	float cosThetaTransmitted = dot(normal, transmissionDirection);
	float reflectionCoefficientSPolarized = pow((refractiveIndexIncident * cosThetaIncident - refractiveIndexTransmitted * cosThetaTransmitted)   /   (refractiveIndexIncident * cosThetaIncident + refractiveIndexTransmitted * cosThetaTransmitted)   , 2);
    float reflectionCoefficientPPolarized = pow((refractiveIndexIncident * cosThetaTransmitted - refractiveIndexTransmitted * cosThetaIncident)   /   (refractiveIndexIncident * cosThetaTransmitted + refractiveIndexTransmitted * cosThetaIncident)   , 2);
	float reflectionCoefficientUnpolarized = (reflectionCoefficientSPolarized + reflectionCoefficientPPolarized) / 2.0; // Equal mix.
	return clamp(reflectionCoefficientUnpolarized, 0.0f, 1.0f);
}

uniform vec3 light;

void main()
{
    if(gl_GlobalInvocationID.x < sceneRes.x && gl_GlobalInvocationID.y < sceneRes.y){
        uint t = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(sceneRes.x);
        uint count = texelInfo[t].count;
        uint last = texelInfo[t].last;
        for(uint i=0;i<count;i++){
            Ray ray = rays[last];
            if(ray.actived > 0 && ray.params.w < 1.0f && ray.params.y < ray.params.z){
                Hit hit = hits[ray.hit];
                if(hit.materialID == materialID && hit.dist < 10000.0f){
                    vec4 tx = texture(tex, hit.texcoord);

                    Ray newRay = ray;
                    newRay.params.w = 1.0f;
                    newRay.origin += newRay.direct * hit.dist;

                    vec3 binormal = normalizeFast(cross(hit.tangent, hit.normal));
                    mat3 tbn = transpose(mat3(hit.tangent, binormal, hit.normal));

                    vec3 prenormal = hit.normal;
                    prenormal = normalizeFast(getNormalMapping(hit.texcoord) * tbn);

                    vec3 normal = -normalizeFast(prenormal * dot(prenormal, newRay.direct));

                    vec3 light = gather(newRay.origin, newRay.direct);
                    vec3 color = tx.rgb * light;

                    float iorIn = 1.0f;
                    float iorOut = 1.3333f;

                    bool cond = dot(prenormal, newRay.direct) <= 0;
                    float coef = cond ? iorIn / iorOut : iorOut / iorIn;
                    vec3 refr = refract(newRay.direct, normal, coef);
                    float fres = computeFresnel(
                        normal,
                        newRay.direct,
                        refr,
                        cond ? iorIn : iorOut,
                        cond ? iorOut : iorIn
                    );

                    float spc = newRay.params.x * texture(spec, hit.texcoord).r * reflectionRate * fres;
                    if(tx.a > 0.999f){
                        newRay.final = mix(newRay.final, color, newRay.params.x);
                        newRay.direct = normalizeFast(reflect(newRay.direct, normal));
                        newRay.params.x = spc;
                        newRay.params.y += 1.0f;
                        if(spc < 0.001f) {
                            newRay.actived = 0;
                        }
                    }

                    newRay.origin += normalizeFast(normal * dot(newRay.direct, normal)) * 0.01f;
                    //storeRay(last, newRay);

                    uint ridx = createRay(newRay);
                    storeTexel(t, ridx);
                    storeHit(rays[ridx], hit);

                    ray.params0.x = 0.0f;
                    ray.actived = 0;
                    storeRay(last, ray);
                }
            }
            last = ray.previous;
        }
    }
}