#version 450 core

struct Thash {
	uint triangle;
	uint previous;
};

struct Voxel {
	uint last;
    uint count;
    uint coordX;
    uint coordY;
    uint coordZ;
};

layout(std430, binding=0) buffer s_voxels {Voxel voxels[];};
layout(std430, binding=1) buffer s_voxels_sub {uint voxels_subgrid[];};
layout(std430, binding=2) buffer s_thashes {Thash thashes[];};
layout(std430, binding=3) buffer s_vbo {float verts[];};
layout(std430, binding=4) buffer s_ebo {uint indics[];};
layout(std430, binding=5) buffer s_to_helper {uint to_helper[];};
layout(std430, binding=6) buffer s_from_helper {uint from_helper[];};

layout (binding=0) uniform atomic_uint vcounter;
layout (binding=1) uniform atomic_uint scounter;
layout (binding=2) uniform atomic_uint lscounter_to;
layout (binding=3) uniform atomic_uint lscounter_from;

uniform uint currentDepth;
uniform uint maxDepth;
uniform vec3 offset;
uniform vec3 scale;

const uint LONGEST = 0xFFFFFFFF;

void store3(in vec3 a, inout float b[3]){
    b[0] = a.x;
    b[1] = a.y;
    b[2] = a.z;
}


#define X 0
#define Y 1
#define Z 2

#define CROSS(dest,v1,v2) \
          dest[0]=v1[1]*v2[2]-v1[2]*v2[1]; \
          dest[1]=v1[2]*v2[0]-v1[0]*v2[2]; \
          dest[2]=v1[0]*v2[1]-v1[1]*v2[0];
#define DOT(v1,v2) (v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2])
#define SUB(dest,v1,v2) \
          dest[0]=v1[0]-v2[0]; \
          dest[1]=v1[1]-v2[1]; \
          dest[2]=v1[2]-v2[2];
#define FINDMINMAX(x0,x1,x2,min,max) \
    min = max = x0;   \
    if(x1<min) min=x1;\
    if(x1>max) max=x1;\
    if(x2<min) min=x2;\
    if(x2>max) max=x2;

int planeBoxOverlap(float normal[3], float vert[3], float maxbox[3])
{
    int q;
    float vmin[3],vmax[3],v;
    for(q=X;q<=Z;q++){
        v=vert[q];
        if(normal[q]>0.0f){
            vmin[q]=-maxbox[q] - v;
            vmax[q]= maxbox[q] - v;
        }else{
            vmin[q]= maxbox[q] - v;
            vmax[q]=-maxbox[q] - v;
        }
    }
    if(DOT(normal,vmin)>0.0f) return 0;
    if(DOT(normal,vmax)>=0.0f) return 1;
    return 0;
}

#define AXISTEST_X01(a, b, fa, fb)			   \
	p0 = a*v0[Y] - b*v0[Z];			       	   \
	p2 = a*v2[Y] - b*v2[Z];			       	   \
        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
	rad = fa * boxhalfsize[Y] + fb * boxhalfsize[Z];   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_X2(a, b, fa, fb)			   \
	p0 = a*v0[Y] - b*v0[Z];			           \
	p1 = a*v1[Y] - b*v1[Z];			       	   \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize[Y] + fb * boxhalfsize[Z];   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Y02(a, b, fa, fb)			   \
	p0 = -a*v0[X] + b*v0[Z];		      	   \
	p2 = -a*v2[X] + b*v2[Z];	       	       	   \
        if(p0<p2) {min=p0; max=p2;} else {min=p2; max=p0;} \
	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Z];   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Y1(a, b, fa, fb)			   \
	p0 = -a*v0[X] + b*v0[Z];		      	   \
	p1 = -a*v1[X] + b*v1[Z];	     	       	   \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Z];   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Z12(a, b, fa, fb)			   \
	p1 = a*v1[X] - b*v1[Y];			           \
	p2 = a*v2[X] - b*v2[Y];			       	   \
        if(p2<p1) {min=p2; max=p1;} else {min=p1; max=p2;} \
	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Y];   \
	if(min>rad || max<-rad) return 0;

#define AXISTEST_Z0(a, b, fa, fb)			   \
	p0 = a*v0[X] - b*v0[Y];				   \
	p1 = a*v1[X] - b*v1[Y];			           \
        if(p0<p1) {min=p0; max=p1;} else {min=p1; max=p0;} \
	rad = fa * boxhalfsize[X] + fb * boxhalfsize[Y];   \
	if(min>rad || max<-rad) return 0;

int triBoxOverlap(float boxcenter[3],float boxhalfsize[3],float triverts[3][3]){
   float v0[3],v1[3],v2[3];
   float min,max,p0,p1,p2,rad,fex,fey,fez;
   float normal[3],e0[3],e1[3],e2[3];

   SUB(v0,triverts[0],boxcenter);
   SUB(v1,triverts[1],boxcenter);
   SUB(v2,triverts[2],boxcenter);

   SUB(e0,v1,v0);
   SUB(e1,v2,v1);
   SUB(e2,v0,v2);

   fex = abs(e0[X]);
   fey = abs(e0[Y]);
   fez = abs(e0[Z]);

   AXISTEST_X01(e0[Z], e0[Y], fez, fey);
   AXISTEST_Y02(e0[Z], e0[X], fez, fex);
   AXISTEST_Z12(e0[Y], e0[X], fey, fex);

   fex = abs(e1[X]);
   fey = abs(e1[Y]);
   fez = abs(e1[Z]);

   AXISTEST_X01(e1[Z], e1[Y], fez, fey);
   AXISTEST_Y02(e1[Z], e1[X], fez, fex);
   AXISTEST_Z0(e1[Y], e1[X], fey, fex);

   fex = abs(e2[X]);
   fey = abs(e2[Y]);
   fez = abs(e2[Z]);

   AXISTEST_X2(e2[Z], e2[Y], fez, fey);
   AXISTEST_Y1(e2[Z], e2[X], fez, fex);
   AXISTEST_Z12(e2[Y], e2[X], fey, fex);

   FINDMINMAX(v0[X],v1[X],v2[X],min,max);
   if(min>boxhalfsize[X] || max<-boxhalfsize[X]) return 0;

   FINDMINMAX(v0[Y],v1[Y],v2[Y],min,max);
   if(min>boxhalfsize[Y] || max<-boxhalfsize[Y]) return 0;

   FINDMINMAX(v0[Z],v1[Z],v2[Z],min,max);
   if(min>boxhalfsize[Z] || max<-boxhalfsize[Z]) return 0;

   CROSS(normal,e0,e1);
   if(planeBoxOverlap(normal,v0,boxhalfsize) < 1) return 0;
   return 1;
}


layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint idx = gl_GlobalInvocationID.x;
    uint resX = uint(pow(2, currentDepth));

    float bhalfsize[3];
    store3(vec3(0.5), bhalfsize);

    if(currentDepth == 0) {
        if(idx == 0){
            uint hloc = atomicCounterIncrement(lscounter_to);
            to_helper[hloc] = 0;
            Voxel voxel;
            voxel.last = LONGEST;
            voxel.count = 0;
            voxel.coordX = 0;
            voxel.coordY = 0;
            voxel.coordZ = 0;

            uint loc = atomicCounterIncrement(scounter);
            voxels[loc] = voxel;
        }
    } else {
        uint spr = idx / 8;
        if(spr < atomicCounter(lscounter_from)){
            uint parent = from_helper[spr];

            uint loc = idx % 8;
            uint w = loc % 2;
            uint h = (loc / 2) % 2;
            uint d = loc / 4;
            uvec3 co = uvec3(w, h, d);

            Voxel voxel = voxels[parent];
            uvec3 parentSpace = uvec3(voxel.coordX, voxel.coordY, voxel.coordZ);
            uvec3 globalSpace = parentSpace * 2 + co;

            vec3 norm = vec3(globalSpace) + 0.5;
            float bcenter[3]; store3(norm, bcenter);

            uint triangleCount = 300000;
            Thash hash = thashes[voxel.last];
            bool needsSkip = false;
            for(uint i=0;i<=min(voxel.count, triangleCount);i++){
                if(!needsSkip){
                    vec3 trivert[3];

                    uint tri = hash.triangle;
                    uint j = 0;
                    j = indics[tri * 3 + 0];
                    trivert[0] = vec3(verts[j * 3 + 0], verts[j * 3 + 1], verts[j * 3 + 2]);
                    j = indics[tri * 3 + 1];
                    trivert[1] = vec3(verts[j * 3 + 0], verts[j * 3 + 1], verts[j * 3 + 2]);
                    j = indics[tri * 3 + 2];
                    trivert[2] = vec3(verts[j * 3 + 0], verts[j * 3 + 1], verts[j * 3 + 2]);

                    for (int i = 0; i < 3; i++) {
                        vec3 pos = trivert[i];
                        pos -= offset;
                        pos /= scale;
                        pos *= resX;
                        trivert[i] = pos;
                    }

                    float triverts[3][3];
                    store3(trivert[0], triverts[0]);
                    store3(trivert[1], triverts[1]);
                    store3(trivert[2], triverts[2]);

                    if(triBoxOverlap(bcenter, bhalfsize, triverts) == 1){
                        Voxel newVoxel;
                        newVoxel.coordX = globalSpace.x;
                        newVoxel.coordY = globalSpace.y;
                        newVoxel.coordZ = globalSpace.z;
                        newVoxel.count = 0;
                        newVoxel.last = LONGEST;

                        uint vloc = atomicCounterIncrement(scounter);
                        uint hloc = atomicCounterIncrement(lscounter_to);
                        to_helper[hloc] = vloc;

                        voxels[vloc] = newVoxel;
                        voxels_subgrid[parent * 8 + loc] = vloc;

                        needsSkip = true;
                    }

                    uint previous = hash.previous;
                    if(previous != LONGEST){
                        hash = thashes[previous];
                    } else {
                        needsSkip = true;
                    }
                } else {
                    break;
                }
            }
        }
    }
}